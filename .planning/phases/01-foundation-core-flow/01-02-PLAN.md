---
phase: 01-foundation-core-flow
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - challenge_tracker/lib/features/challenges/data/repositories/challenge_repository.dart
  - challenge_tracker/lib/features/challenges/presentation/notifiers/challenge_list_notifier.dart
  - challenge_tracker/lib/features/challenges/data/services/hive_service.dart
autonomous: true

must_haves:
  truths:
    - "Repository can create new challenge and persist it"
    - "Repository can mark challenge complete with UTC timestamp"
    - "Repository can undo same-day completion"
    - "AsyncNotifier loads challenges on initialization"
    - "State updates trigger UI rebuilds"
  artifacts:
    - path: "challenge_tracker/lib/features/challenges/data/repositories/challenge_repository.dart"
      provides: "Challenge CRUD operations"
      contains: "markComplete"
    - path: "challenge_tracker/lib/features/challenges/presentation/notifiers/challenge_list_notifier.dart"
      provides: "Riverpod AsyncNotifier for challenge state"
      contains: "@riverpod"
    - path: "challenge_tracker/lib/features/challenges/presentation/notifiers/challenge_list_notifier.g.dart"
      provides: "Generated provider"
      contains: "challengeListProvider"
  key_links:
    - from: "challenge_list_notifier.dart"
      to: "challenge_repository.dart"
      via: "ref.read"
      pattern: "ref\\.read\\(challengeRepositoryProvider\\)"
    - from: "challenge_repository.dart"
      to: "hive_service.dart"
      via: "dependency injection"
      pattern: "HiveService"
---

<objective>
Create the repository layer for challenge CRUD operations and Riverpod state management with AsyncNotifier.

Purpose: Enables UI to read/write challenge data reactively. The notifier handles async loading, mutations, and state updates that trigger rebuilds.
Output: ChallengeRepository with full CRUD + completion logic, ChallengeListNotifier that UI can watch.
</objective>

<execution_context>
@/Users/angelrodriguez/.claude/get-shit-done/workflows/execute-plan.md
@/Users/angelrodriguez/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-flow/01-RESEARCH.md
@.planning/phases/01-foundation-core-flow/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChallengeRepository with CRUD and completion logic</name>
  <files>
    challenge_tracker/lib/features/challenges/data/repositories/challenge_repository.dart
  </files>
  <action>
1. Create directory: lib/features/challenges/data/repositories/

2. Create challenge_repository.dart:
```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:uuid/uuid.dart';
import '../models/challenge.dart';
import '../models/challenge_pack.dart';
import '../services/hive_service.dart';
import '../../../../core/utils/streak_calculator.dart';

part 'challenge_repository.g.dart';

@riverpod
ChallengeRepository challengeRepository(ChallengeRepositoryRef ref) {
  return ChallengeRepository(hiveService: HiveService());
}

class ChallengeRepository {
  final HiveService _hiveService;
  final Uuid _uuid = const Uuid();

  ChallengeRepository({required HiveService hiveService})
      : _hiveService = hiveService;

  /// Get all challenges
  Future<List<Challenge>> getAllChallenges() async {
    return await _hiveService.getAllChallenges();
  }

  /// Get single challenge by ID
  Future<Challenge?> getChallenge(String id) async {
    return await _hiveService.getChallenge(id);
  }

  /// Create new challenge from pack
  Future<Challenge> createChallenge({
    required ChallengePack pack,
    required int startDateUtc,
    int? reminderTimeMinutes,
  }) async {
    final challenge = Challenge(
      id: _uuid.v4(),
      name: pack.name,
      packId: pack.id,
      startDateUtc: startDateUtc,
      completionDatesUtc: [],
      reminderTimeMinutes: reminderTimeMinutes,
      isStreakFrozen: false,
    );

    await _hiveService.saveChallenge(challenge);
    return challenge;
  }

  /// Mark challenge complete for today
  /// Returns updated challenge
  Future<Challenge> markComplete(String challengeId) async {
    final challenge = await _hiveService.getChallenge(challengeId);
    if (challenge == null) {
      throw Exception('Challenge not found: $challengeId');
    }

    // Check if already completed today
    if (StreakCalculator.isCompletedToday(challenge.completionDatesUtc)) {
      return challenge; // Already done, no-op
    }

    // Add today's completion
    final utcTimestamp = StreakCalculator.getCurrentUtcTimestamp();
    final updatedCompletions = [...challenge.completionDatesUtc, utcTimestamp];

    final updatedChallenge = challenge.copyWith(
      completionDatesUtc: updatedCompletions,
      isStreakFrozen: false, // Unfreeze on completion
    );

    await _hiveService.saveChallenge(updatedChallenge);
    return updatedChallenge;
  }

  /// Undo completion for today (same day only)
  /// Returns updated challenge, or null if no completion to undo
  Future<Challenge?> undoTodayCompletion(String challengeId) async {
    final challenge = await _hiveService.getChallenge(challengeId);
    if (challenge == null) {
      throw Exception('Challenge not found: $challengeId');
    }

    // Find today's completion timestamp
    final todayTimestamp = StreakCalculator.getTodayCompletionTimestamp(
      challenge.completionDatesUtc,
    );

    if (todayTimestamp == null) {
      return null; // Nothing to undo
    }

    // Remove today's completion
    final updatedCompletions = challenge.completionDatesUtc
        .where((ts) => ts != todayTimestamp)
        .toList();

    final updatedChallenge = challenge.copyWith(
      completionDatesUtc: updatedCompletions,
    );

    await _hiveService.saveChallenge(updatedChallenge);
    return updatedChallenge;
  }

  /// Toggle streak freeze for today (forgiveness feature)
  Future<Challenge> toggleStreakFreeze(String challengeId) async {
    final challenge = await _hiveService.getChallenge(challengeId);
    if (challenge == null) {
      throw Exception('Challenge not found: $challengeId');
    }

    final updatedChallenge = challenge.copyWith(
      isStreakFrozen: !challenge.isStreakFrozen,
    );

    await _hiveService.saveChallenge(updatedChallenge);
    return updatedChallenge;
  }

  /// Update reminder time for challenge
  Future<Challenge> updateReminderTime(String challengeId, int? reminderTimeMinutes) async {
    final challenge = await _hiveService.getChallenge(challengeId);
    if (challenge == null) {
      throw Exception('Challenge not found: $challengeId');
    }

    final updatedChallenge = challenge.copyWith(
      reminderTimeMinutes: reminderTimeMinutes,
    );

    await _hiveService.saveChallenge(updatedChallenge);
    return updatedChallenge;
  }

  /// Delete challenge
  Future<void> deleteChallenge(String challengeId) async {
    await _hiveService.deleteChallenge(challengeId);
  }
}
```

NOTE: Using @riverpod annotation for automatic provider generation. Repository is instantiated fresh each time (stateless).
  </action>
  <verify>
Run: `cd challenge_tracker && flutter analyze lib/features/challenges/data/repositories/`
Expected: Warning about missing .g.dart file (will be generated next task)
  </verify>
  <done>
- ChallengeRepository exists with getAllChallenges, createChallenge, markComplete, undoTodayCompletion, toggleStreakFreeze, deleteChallenge
- Uses HiveService for persistence
- Uses StreakCalculator for completion checks
- @riverpod annotation present for provider generation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ChallengeListNotifier with AsyncNotifier pattern</name>
  <files>
    challenge_tracker/lib/features/challenges/presentation/notifiers/challenge_list_notifier.dart
  </files>
  <action>
1. Create directory: lib/features/challenges/presentation/notifiers/

2. Create challenge_list_notifier.dart following RESEARCH.md Pattern 3:
```dart
import 'package:riverpod_annotation/riverpod_annotation.dart';
import '../../data/models/challenge.dart';
import '../../data/models/challenge_pack.dart';
import '../../data/repositories/challenge_repository.dart';

part 'challenge_list_notifier.g.dart';

@riverpod
class ChallengeList extends _$ChallengeList {
  @override
  Future<List<Challenge>> build() async {
    // Initial load from repository
    final repository = ref.read(challengeRepositoryProvider);
    return await repository.getAllChallenges();
  }

  /// Reload challenges from storage
  Future<void> refresh() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(challengeRepositoryProvider);
      return await repository.getAllChallenges();
    });
  }

  /// Create new challenge from pack
  Future<void> createChallenge({
    required ChallengePack pack,
    required int startDateUtc,
    int? reminderTimeMinutes,
  }) async {
    state = await AsyncValue.guard(() async {
      final repository = ref.read(challengeRepositoryProvider);
      await repository.createChallenge(
        pack: pack,
        startDateUtc: startDateUtc,
        reminderTimeMinutes: reminderTimeMinutes,
      );
      return await repository.getAllChallenges();
    });
  }

  /// Mark challenge complete for today
  Future<void> markComplete(String challengeId) async {
    state = await AsyncValue.guard(() async {
      final repository = ref.read(challengeRepositoryProvider);
      await repository.markComplete(challengeId);
      return await repository.getAllChallenges();
    });
  }

  /// Undo today's completion
  Future<void> undoTodayCompletion(String challengeId) async {
    state = await AsyncValue.guard(() async {
      final repository = ref.read(challengeRepositoryProvider);
      await repository.undoTodayCompletion(challengeId);
      return await repository.getAllChallenges();
    });
  }

  /// Toggle streak freeze
  Future<void> toggleStreakFreeze(String challengeId) async {
    state = await AsyncValue.guard(() async {
      final repository = ref.read(challengeRepositoryProvider);
      await repository.toggleStreakFreeze(challengeId);
      return await repository.getAllChallenges();
    });
  }

  /// Delete challenge
  Future<void> deleteChallenge(String challengeId) async {
    state = await AsyncValue.guard(() async {
      final repository = ref.read(challengeRepositoryProvider);
      await repository.deleteChallenge(challengeId);
      return await repository.getAllChallenges();
    });
  }
}

/// Provider for single challenge by ID (derived from list)
@riverpod
Challenge? challengeById(ChallengeByIdRef ref, String id) {
  final challengesAsync = ref.watch(challengeListProvider);
  return challengesAsync.maybeWhen(
    data: (challenges) {
      try {
        return challenges.firstWhere((c) => c.id == id);
      } catch (_) {
        return null;
      }
    },
    orElse: () => null,
  );
}
```

KEY PATTERNS (from RESEARCH.md):
- Uses AsyncValue.guard() for automatic loading/error handling
- Returns fresh list after each mutation (immutable state)
- ref.read in methods (not watch) to avoid rebuild loops
- Derived provider (challengeById) for single challenge access
  </action>
  <verify>
Run: `cd challenge_tracker && flutter analyze lib/features/challenges/presentation/notifiers/`
Expected: Warning about missing .g.dart file
  </verify>
  <done>
- ChallengeListNotifier extends _$ChallengeList (generated base)
- build() loads all challenges on init
- Commands: createChallenge, markComplete, undoTodayCompletion, toggleStreakFreeze, deleteChallenge
- All commands use AsyncValue.guard and reload full list
- challengeById derived provider for single challenge access
  </done>
</task>

<task type="auto">
  <name>Task 3: Run build_runner and verify all providers generate</name>
  <files>
    challenge_tracker/lib/features/challenges/data/repositories/challenge_repository.g.dart
    challenge_tracker/lib/features/challenges/presentation/notifiers/challenge_list_notifier.g.dart
  </files>
  <action>
1. Add HiveService provider for dependency injection (update hive_service.dart):
```dart
// Add at top of file
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'hive_service.g.dart';

@riverpod
HiveService hiveService(HiveServiceRef ref) {
  return HiveService();
}

// Rest of class unchanged...
```

2. Update challenge_repository.dart to use injected HiveService:
```dart
// Update provider to use ref
@riverpod
ChallengeRepository challengeRepository(ChallengeRepositoryRef ref) {
  return ChallengeRepository(hiveService: ref.read(hiveServiceProvider));
}
```

3. Run build_runner to generate all providers:
```bash
cd challenge_tracker && flutter pub run build_runner build --delete-conflicting-outputs
```

4. Verify generated files exist:
- lib/features/challenges/data/models/challenge.g.dart (Hive adapter)
- lib/features/challenges/data/services/hive_service.g.dart (provider)
- lib/features/challenges/data/repositories/challenge_repository.g.dart (provider)
- lib/features/challenges/presentation/notifiers/challenge_list_notifier.g.dart (notifier + providers)

5. Run flutter analyze to verify no errors:
```bash
cd challenge_tracker && flutter analyze
```

6. Quick smoke test - update main.dart to verify provider works:
```dart
// Add temporary test in ChallengeTrackerApp build method (remove after verification)
// This just ensures the provider compiles correctly
// home: Consumer(
//   builder: (context, ref, child) {
//     final challengesAsync = ref.watch(challengeListProvider);
//     return challengesAsync.when(
//       data: (challenges) => Text('${challenges.length} challenges'),
//       loading: () => CircularProgressIndicator(),
//       error: (e, s) => Text('Error: $e'),
//     );
//   },
// ),
```
  </action>
  <verify>
Run: `cd challenge_tracker && flutter pub run build_runner build --delete-conflicting-outputs && flutter analyze && flutter build ios --no-codesign --debug 2>&1 | head -20`
Expected: All .g.dart files generated, analysis passes, build starts successfully
  </verify>
  <done>
- challenge.g.dart exists with ChallengeAdapter
- hive_service.g.dart exists with hiveServiceProvider
- challenge_repository.g.dart exists with challengeRepositoryProvider
- challenge_list_notifier.g.dart exists with challengeListProvider and challengeByIdProvider
- flutter analyze passes with no errors
- App builds successfully
  </done>
</task>

</tasks>

<verification>
1. `flutter pub run build_runner build --delete-conflicting-outputs` - all .g.dart files generated
2. `flutter analyze` - no errors
3. Check generated providers exist: hiveServiceProvider, challengeRepositoryProvider, challengeListProvider, challengeByIdProvider
4. Quick run `flutter run` - app launches without crashes
</verification>

<success_criteria>
- ChallengeRepository with full CRUD operations and completion logic
- ChallengeListNotifier with AsyncNotifier pattern using @riverpod
- All providers generated by build_runner: hiveServiceProvider, challengeRepositoryProvider, challengeListProvider, challengeByIdProvider
- Repository uses dependency injection for HiveService
- AsyncValue.guard pattern used in all notifier mutations
- flutter analyze passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-flow/01-02-SUMMARY.md`
</output>
